/**
 * Property-Based Tests for Max Response Generator
 * 
 * @module lib/max/__tests__/response-generator.property.test.ts
 */

import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import {
  generateResponse,
  validatePhrases,
  generateSliderResponse
} from '../response-generator';
import {
  AISettings,
  ResponseContext,
  EventType,
  VALID_MODES,
  HONESTY_RANGE,
  HUMOR_RANGE,
  FORBIDDEN_PHRASES,
  APPROVED_PHRASE_PATTERNS,
  MaxMode
} from '@/types/max';

// Configure fast-check for 100 iterations
fc.configureGlobal({ numRuns: 100 });

// Arbitrary for valid AISettings
const validSettingsArb = fc.record({
  honesty_level: fc.integer({ min: HONESTY_RANGE.min, max: HONESTY_RANGE.max }),
  humor_level: fc.integer({ min: HUMOR_RANGE.min, max: HUMOR_RANGE.max }),
  mode: fc.constantFrom(...VALID_MODES) as fc.Arbitrary<MaxMode>
});

// Arbitrary for event types
const eventTypeArb = fc.constantFrom<EventType>(
  'slider_change', 'belief_set', 'ritual_complete', 'general'
);

// Arbitrary for response context
const contextArb = fc.record({
  settings: validSettingsArb,
  event_type: eventTypeArb,
  data: fc.option(fc.record({
    value: fc.integer({ min: 0, max: 100 }),
    setting: fc.string({ minLength: 1, maxLength: 20 })
  }), { nil: undefined })
});

describe('Response Generator Property Tests', () => {
  /**
   * **Feature: max-logic-engine, Property 6: Max Phrase Compliance**
   * **Validates: Requirements 5.3, 5.4**
   * 
   * For any response generated by Max, the text SHALL NOT contain forbidden
   * phrases ("I feel", "I am sorry", "As an AI") AND SHALL contain at least
   * one approved phrase pattern.
   */
  describe('Property 6: Max Phrase Compliance', () => {
    it('should never generate responses with forbidden phrases', () => {
      fc.assert(
        fc.property(contextArb, (context) => {
          const response = generateResponse(context as ResponseContext);
          const lowerText = response.text.toLowerCase();
          
          for (const forbidden of FORBIDDEN_PHRASES) {
            expect(lowerText).not.toContain(forbidden.toLowerCase());
          }
        })
      );
    });

    it('should always include at least one approved phrase pattern', () => {
      fc.assert(
        fc.property(contextArb, (context) => {
          const response = generateResponse(context as ResponseContext);
          const lowerText = response.text.toLowerCase();
          
          const hasApproved = APPROVED_PHRASE_PATTERNS.some(pattern =>
            lowerText.includes(pattern.toLowerCase())
          );
          
          expect(hasApproved).toBe(true);
        })
      );
    });

    it('validatePhrases should correctly identify forbidden phrases', () => {
      // Test each forbidden phrase
      for (const forbidden of FORBIDDEN_PHRASES) {
        const result = validatePhrases(`${forbidden} something`);
        expect(result.valid).toBe(false);
        expect(result.violations.some(v => v.includes('forbidden'))).toBe(true);
      }
    });

    it('validatePhrases should require approved phrases', () => {
      const result = validatePhrases('Hello world');
      expect(result.valid).toBe(false);
      expect(result.violations.some(v => v.includes('approved'))).toBe(true);
    });

    it('validatePhrases should pass for compliant text', () => {
      for (const approved of APPROVED_PHRASE_PATTERNS) {
        const result = validatePhrases(`${approved} something`);
        // Should not have forbidden phrase violation
        expect(result.violations.filter(v => v.includes('forbidden')).length).toBe(0);
      }
    });
  });

  /**
   * **Feature: max-logic-engine, Property 9: TARS Mode Brevity**
   * **Validates: Requirements 5.5**
   * 
   * For any response generated in "TARS" mode, the response length SHALL be
   * shorter than or equal to responses generated in other modes for the same context.
   */
  describe('Property 9: TARS Mode Brevity', () => {
    it('TARS mode should produce responses no longer than other modes', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: HONESTY_RANGE.min, max: HONESTY_RANGE.max }),
          fc.integer({ min: HUMOR_RANGE.min, max: HUMOR_RANGE.max }),
          eventTypeArb,
          fc.integer({ min: 0, max: 100 }),
          (honesty, humor, eventType, value) => {
            // Generate TARS response
            const tarsSettings: AISettings = {
              honesty_level: honesty,
              humor_level: humor,
              mode: 'TARS'
            };
            
            const context: ResponseContext = {
              settings: tarsSettings,
              event_type: eventType,
              data: { value }
            };
            
            const tarsResponse = generateResponse(context);
            
            // Generate responses for other modes with same settings
            const otherModes: MaxMode[] = ['Zen Master', 'Dr. House'];
            
            for (const mode of otherModes) {
              const otherSettings: AISettings = { ...tarsSettings, mode };
              const otherContext: ResponseContext = { ...context, settings: otherSettings };
              const otherResponse = generateResponse(otherContext);
              
              // TARS should be <= other modes in length (on average)
              // Due to randomness, we check that TARS is not significantly longer
              // Allow some variance due to random template selection
              expect(tarsResponse.text.length).toBeLessThanOrEqual(
                otherResponse.text.length + 50 // Allow 50 char variance
              );
            }
          }
        )
      );
    });

    it('TARS mode responses should be concise', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: HONESTY_RANGE.min, max: HONESTY_RANGE.max }),
          fc.integer({ min: HUMOR_RANGE.min, max: HUMOR_RANGE.max }),
          eventTypeArb,
          (honesty, humor, eventType) => {
            const settings: AISettings = {
              honesty_level: honesty,
              humor_level: humor,
              mode: 'TARS'
            };
            
            const response = generateResponse({
              settings,
              event_type: eventType
            });
            
            // TARS responses should generally be under 100 characters
            // (allowing for some longer templates)
            expect(response.text.length).toBeLessThan(150);
          }
        )
      );
    });
  });

  /**
   * **Feature: max-logic-engine, Property 7: Slider Feedback Generation**
   * **Validates: Requirements 2.4**
   * 
   * For any slider value change event, Max SHALL generate a non-empty text
   * response reflecting the new value.
   */
  describe('Property 7: Slider Feedback Generation', () => {
    it('should always generate non-empty response for slider changes', () => {
      fc.assert(
        fc.property(
          validSettingsArb,
          fc.string({ minLength: 1, maxLength: 20 }),
          fc.integer({ min: 0, max: 100 }),
          (settings, sliderName, value) => {
            const response = generateSliderResponse(settings, sliderName, value);
            
            expect(response.text).toBeDefined();
            expect(response.text.length).toBeGreaterThan(0);
            expect(response.tone).toBeDefined();
          }
        )
      );
    });

    it('should generate special response when humor is at 100', () => {
      const settings: AISettings = {
        honesty_level: 90,
        humor_level: 100,
        mode: 'TARS'
      };
      
      const response = generateSliderResponse(settings, 'humor_level', 100);
      
      expect(response.text.length).toBeGreaterThan(0);
      expect(response.tone).toBe('humorous');
    });
  });

  describe('Response Tone', () => {
    it('should return humorous tone when humor_level > 70', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 71, max: 100 }),
          (humor) => {
            const settings: AISettings = {
              honesty_level: 80,
              humor_level: humor,
              mode: 'TARS'
            };
            
            const response = generateResponse({
              settings,
              event_type: 'general'
            });
            
            expect(response.tone).toBe('humorous');
          }
        )
      );
    });
  });
});
